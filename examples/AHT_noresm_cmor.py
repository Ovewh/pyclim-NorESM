#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Friday November 24 17:08:18 2021

@author: Ada Gjermundsen

Calculates atmospheic energy transport (dry static, latent, kinetic)

The atmospheric energy transport functions can be used to calculate e.g.
- zonal mean values
- timeseries of transport across a given latitude
- seasonal averages or timeseries of seasonal averages

It is useful to reduce the data by either 
- select a time slice for the period needed
- consider the transport across a given latitude band
- make time (e.g. yearly) averages
  
"""

import sys
# path to the pyclim-noresm folder. Please change to something more meaningful it this doesn't work out 
sys.path.insert(1, '/nird/home/adagj/pyclim-NorESM/pyclim-noresm/')
from reading_routines_noresm import read_noresm_cmor, Modelinfo
import general_util_funcs as guf
import atmospheric_transport_functions as atf
import xarray as xr
xr.set_options(enable_cftimeindex=True)
from dask.diagnostics import ProgressBar
import warnings
warnings.simplefilter('ignore')

def make_attributes(ds, energy_type, timeavg, yr1, yr2, lat_lim=None):
     '''
     Set DataArray attributes before writing the dataset to file
     
     Parameters
     ----------
     ds :   xarray.Dataset with atmospheric energy transport DataArrays

     Returns
     -------
     ds :   xarray.Dataset with atmospheric energy transport DataArrays
            same as what came in but now with lots of details 
     '''
     ds.attrs['description']='%s atmospheric energy transport (total = moist + dry static + kinetic)'%energy_type
     ds.attrs['units']='PW'
     ds.attrs['energy_component'] = '%s energy'%energy_type
     ds.attrs['standard_name']='atmospheric_heat_transport'
     ds.attrs['long_name']= '%s averaged %s atmospheric heat tranport'%(timeavg, energy_type)
     if lat_lim:
         ds.attrs['latitude_limit'] = '%.2f degrees north'%lat_lim
     else:
         ds.attrs['latitude_limit'] = 'zonally averaged'
     ds.attrs['average_period_years']=str(yr1)+ '-' + str(yr2)
     return ds

def atmos_dataset(model, yr1=None, yr2=None):
    '''
    This function load all the variables needed into one dataset, select the time periode under consideration 
    and calcuates the pressure thickness for the same dimensions and adds it to the dataset

    Parameters
    ----------
    model :          python object, with experiment details as attributes (generated by class Modelinfo )
    yr1   :          int, first year to choose for time slicing. Default is None
    yr2   :          int, last year to choose for time slicing. Default is None

    Returns
    -------
    ds_atm:            xarray.Dataset with variables needed to calculate the energy transport in the atmophsere
  
    It is useful to reduce the amount of data by selecting a time slice for the period needed
   
    '''

    ds_cfmon = read_noresm_cmor(model, varlist=['ta','hus'], realm = 'CFmon', grid = 'gn', dim='time', transform_func=lambda ds: guf.consistent_naming(ds))  
    ds_aermon = read_noresm_cmor(model, varlist=['ua','va','zg'], realm = 'AERmon', grid = 'gn', dim='time', transform_func=lambda ds: guf.consistent_naming(ds))
    ds_atm = xr.merge([ds_cfmon, ds_aermon]) 
    if yr1 or yr2:
       ds_atm = atf.select_time(ds_atm, yr1=yr1, yr2=yr2)
    # calculate pressure thickness
    dp = atf.make_pressure_bnds(ds_atm[['a_bnds','b_bnds','ps','p0']])
    ds_atm = xr.merge([ds_atm, dp])
    return ds_atm

def aht_yearly(ds, lat_lim=None):
    '''
    This function calculates the atmospheric energy transport across a given latitude given by lat_lim 
    averaged over the whole time slice of the dataset. If time series i wanted, just remove the .mean(dim='year')
    from aht = pw*(guf.yearly_avg(energy_flux).mean(dim='year')).sum()

    Also included are yearly averages across the given latitude band as a function of height and a function of longitude


    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport 
    lat_lim: int or float, latitude band for which the energy transport is calculated across  
    
    Returns
    -------
    ds_out:     xarray.Dataset with yearly averaged atmospheric energy transport across lat_lim 
    '''

    ds_out = None
    if lat_lim:
       ds = atf.select_region(ds, lat_lim=lat_lim)
    else:
       raise Exception('Please set a value for latitude band. If not this script will crash due to memory issues')
    ef_tot, ef_moist, ef_dry , ef_kinetic = atf.atmos_energy_flux(ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds)   
    yr1 = ds.time.values[0].year
    yr2 = ds.time.values[-1].year
    pw = 1e-15 # convert to peta watt
    lat_lim = ds.lat.values # to get the actual value for the latitude band used in the calculations
    for energy_flux, energy_type in zip([ef_tot, ef_moist, ef_dry , ef_kinetic],['total', 'latent', 'dry_static', 'kinetic']):
        aht = pw*(guf.yearly_avg(energy_flux).mean(dim='year')).sum()
        print(energy_type + ' AHT @ %.2f degrees north: %.4f PW'%(lat_lim,aht.values))
        aht = make_attributes(aht, energy_type, 'Yearly', yr1, yr2, lat_lim)
        aht = aht.to_dataset(name='aht_' + energy_type)
        # it can be quite useful to see the the energy transport variation with height as well,
        # but it slows down the calculations, so please comment out all the aht_height stuff if not needed
        aht_height = pw*(guf.yearly_avg(energy_flux).mean(dim='year')).sum(dim='lon')
        aht_height = make_attributes(aht_height, energy_type, 'Yearly', yr1, yr2, lat_lim)
        aht_height = aht_height.to_dataset(name='aht_height_' + energy_type)
        # it can be quite useful to see the the energy transport variation with longitude as well,
        # in order to see which region(s) dominates the transport
        # but it slows down the calculations, so please comment out all the aht_lin stuff if not needed
        aht_lon = pw*(guf.yearly_avg(energy_flux).mean(dim='year')).sum(dim='lev')
        aht_lon = make_attributes(aht_lon, energy_type, 'Yearly', yr1, yr2, lat_lim)
        aht_lon = aht_lon.to_dataset(name='aht_lon_' + energy_type)
        if isinstance(ds_out,xr.Dataset):
            ds_out = xr.merge([ds_out, aht, aht_height, aht_lon])
        else: 
            ds_out = xr.merge([ aht, aht_height, aht_lon])
    return ds_out

def aht_zonal(ds):
    '''
    This function calculates the zonally averaged atmospheric energy transport 
    averaged over the whole time slice of the dataset. If seasonal or monthly averaged are needed instead,
    it is possible to combine several of the functions in this script :)

    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport   
    
    Returns
    -------
    ds_out:     xarray.Dataset with yearly and zonally averaged atmospheric energy transport 

    '''

    ds_out = None
    ef_tot, ef_moist, ef_dry , ef_kinetic = atf.atmos_energy_flux(ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds)
    yr1 = ds.time.values[0].year
    yr2 = ds.time.values[-1].year
    pw = 1e-15 # convert to peta watt
    for energy_flux, energy_type in zip([ef_tot, ef_moist, ef_dry , ef_kinetic],['total', 'latent', 'dry_static', 'kinetic']):
        aht = pw*(guf.yearly_avg(energy_flux).mean(dim='year')).sum(dim=('lon','lev'))
        aht = make_attributes(aht, energy_type, 'Yearly', yr1, yr2, lat_lim = None)
        aht = aht.to_dataset(name='aht_zonal_' + energy_type)
        if isinstance(ds_out,xr.Dataset):
            ds_out = xr.merge([ds_out, aht])
        else:
            ds_out = aht
    return ds_out


def aht_season(ds, lat_lim=None):
    '''
    This function calculates the atmospheric energy transport across a given latitude given by lat_lim 
    seaonally averaged (SON, DJF, MAM, JJA) over the whole time slice of the dataset. 

    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport 
    lat_lim: int or float, latitude band for which the energy transport is calculated across  
    
    Returns
    -------
    ds_out:     xarray.Dataset with sesonal (SON, DJF, MAM, JJA) averaged atmospheric energy transport across lat_lim 
    '''

    ds_out = None
    if lat_lim:
       ds = atf.select_region(ds, lat_lim=lat_lim)
    else:
       raise Exception('Please set a value for latitude band. If not this script will crash due to memory issues')
    ef_tot, ef_moist, ef_dry , ef_kinetic = atf.atmos_energy_flux(ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds)
    yr1 = ds.time.values[0].year
    yr2 = ds.time.values[-1].year
    pw = 1e-15 # convert to peta watt
    lat_lim = ds.lat.values # to get the actual value for the latitude band used in the calculations
    for energy_flux, energy_type in zip([ef_tot, ef_moist, ef_dry , ef_kinetic],['total', 'latent', 'dry_static', 'kinetic']):
        ses_avg = guf.seasonal_avg(energy_flux)
        ses_avg = pw*ses_avg.sum(dim=('lon','lev'))
        for ses in ['DJF', 'JJA', 'MAM', 'SON']:
            da = ses_avg.sel(season=ses)
            da = da.drop('season')
            print(energy_type + ' AHT @ %.2f degrees north for season %s: %.4f PW'%(lat_lim, ses, da.values))
            da = make_attributes(da, energy_type, ses, yr1, yr2, lat_lim)
            da = da.to_dataset(name = 'aht_' + ses+ '_'+energy_type)
            if isinstance(ds_out,xr.Dataset):
                ds_out = xr.merge([ds_out, da])
            else:
                ds_out = da
            del da
    return ds_out

def aht_monthly(ds, lat_lim=None):
    '''
    This function calculates the atmospheric energy transport across a given latitude given by lat_lim 
    averaged for each month for the whole time slice of the dataset.
    Also included are montly averages across the given latitude band as a function of height

    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport 
    lat_lim: int or float, latitude band for which the energy transport is calculated across  
    
    Returns
    -------
    ds_out:     xarray.Dataset with monthly (Jan, Feb, March, etc.) averaged atmospheric energy transport across lat_lim 
    '''
    monthnames_short = ['jan', 'feb', 'mar', 'apr', 'may', 'june', 'july', 'aug', 'sept','oct','nov','dec']
    monthnames_long = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September','October','November','December']
    ds_out = None
    if lat_lim:
       ds = atf.select_region(ds, lat_lim=lat_lim)
    else:
       raise Exception('Please set a value for latitude band. If not this script will crash due to memory issues')
    ef_tot, ef_moist, ef_dry , ef_kinetic = atf.atmos_energy_flux(ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds)
    yr1 = ds.time.values[0].year
    yr2 = ds.time.values[-1].year
    pw = 1e-15 # convert to peta watt
    lat_lim = ds.lat.values # to get the actual value for the latitude band used in the calculations
    for energy_flux, energy_type in zip([ef_tot, ef_moist, ef_dry , ef_kinetic],['total', 'latent', 'dry_static', 'kinetic']):
        monthly_avg = energy_flux.groupby('time.month').mean(dim='time')
        # it can be quite useful to see the the energy transport variation with height as well, but it slows down the calculations, so please comment out all the _height stuff if not needed
        monthly_avg_height = pw*monthly_avg.sum('lon')
        monthly_avg = pw*monthly_avg.sum(dim=('lon','lev'))
        for month in range(1,13):
            da = monthly_avg.sel(month=month)
            da_height =  monthly_avg_height.sel(month=month)
            da = da.drop('month')
            da_height = da_height.drop('month')
            print(energy_type + ' AHT @ %.2f degrees north for %s: %.4f PW'%(lat_lim, monthnames_long[month-1], da.values))
            da = make_attributes(da, energy_type, monthnames_long[month-1], yr1, yr2, lat_lim)
            da = da.to_dataset(name = 'aht_' + monthnames_short[month-1] + '_'+energy_type)
            da_height = make_attributes(da_height, energy_type, monthnames_long[month-1], yr1, yr2, lat_lim)
            da_height = da_height.to_dataset(name = 'aht_height_' + monthnames_short[month-1] + '_'+energy_type)
            if isinstance(ds_out,xr.Dataset):
                ds_out = xr.merge([ds_out, da, da_height])
            else:
                ds_out = xr.merge([da, da_height])
            del da
    return ds_out

if __name__ == '__main__':
    # please change according to your experiment
    expid = 'historical'                    # name of experiment
    activity_id = 'CMIP'                    # activity id of experiment i.e. which MIP 
    modelname = 'NorESM2-LM'                # name of model
    realiz = 'r1i1p1f1'                     # ensemble member 
    outdir =  '/'  # path to directory where output is stored

    # Create model object with experiment information (not file specific) as attributes
    # for details see Modelinfo in reading_routines_noresm.py
    model = Modelinfo(name = modelname, activity_id = activity_id, expid = expid, realiz=realiz)
    # ATMOSPHERIC ENERGY TRANSPORT
    # read files. Please note, if you don't limit the number of years you probably will run into memory trouble
    yr1 = 2000
    yr2 = 2014
    ds_atm = atmos_dataset(model, yr1=2000, yr2=2014)
    lat_lim = 66
    
    # These are just examples, and please just comment out what you don't need
    # yearly values across a given latitude; lat_lim
    ds_out1 = aht_yearly(ds_atm, lat_lim=lat_lim)
   
    # yearly values, zonally averaged
    ds_out2 = aht_zonal(ds_atm)
      
    # seasonally avereaged values across a given latitude; lat_lim
    ds_out3 = aht_season(ds_atm, lat_lim=lat_lim)
 
    # montly averages across a given latitude; lat_lim
    ds_out4 = aht_monthly(ds_atm, lat_lim=lat_lim)

    combined = xr.merge([ds_out1, ds_out2, ds_out3, ds_out4])
   
    # this is just an example. please change to a filename you find useful 
    filename = outdir + 'AtmosphericEnergyTransport' +'_' + modelname + '_'+ expid + '_' + realiz+ '.%s_%s.nc'%(str(yr1).zfill(4), str(yr2).zfill(4))
    tmp = combined.to_netcdf(filename, compute = False)
    with ProgressBar():
         result = tmp.compute()

    
