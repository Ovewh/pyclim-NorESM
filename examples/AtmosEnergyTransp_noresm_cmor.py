#!/usr/bin/env python3
"""
Created on Friday November 24 17:08:18 2021

@author: Ada Gjermundsen

Calculates atmospheic energy transport (dry static, latent, kinetic)

The atmospheric energy transport functions can be used to calculate e.g.
- zonal mean values
- timeseries of transport across a given latitude
- seasonal averages or timeseries of seasonal averages

It is useful to reduce the data by either 
- select a time slice for the period needed
- consider the transport across a given latitude band
- make time (e.g. yearly) averages
  
"""
from __future__ import annotations

import xarray as xr

import atmospheric_transport_functions as atf
import general_util_funcs as guf
from reading_routines_noresm import Modelinfo, read_noresm_cmor

xr.set_options(enable_cftimeindex=True)
import warnings

from dask.diagnostics import ProgressBar

warnings.simplefilter("ignore")


def make_attributes(
    ds: xr.Dataset, energy_type: str, timeavg: str, first_yr: int, last_yr: int, lat_lim: float | None = None,
) -> xr.Dataset:
    """
     Set DataArray attributes before writing the dataset to file
     
     Parameters
     ----------
     ds :            xarray.Dataset with atmospheric energy transport DataArrays
     energy_type :   str, "total", "latent", "dry_static", "kinetic"
     timeavg :       str, monthly, seasonal or annual mean 
     first_yr :      int, first year of data
     last_yr :       int, last year of data
     lat_lim :       float or None. Latitude band of energy transport. Default = None

     Returns
     -------
     ds :   xarray.Dataset with atmospheric energy transport DataArrays
            same as what came in but now with lots of details 
    """
    ds.attrs["description"] = "%s atmospheric energy transport (total = moist + dry static + kinetic)" % energy_type
    ds.attrs["units"] = "PW"
    ds.attrs["energy_component"] = "%s energy" % energy_type
    ds.attrs["standard_name"] = "atmospheric_heat_transport"
    ds.attrs["long_name"] = "%s averaged %s atmospheric heat tranport" % (timeavg, energy_type,)
    if lat_lim:
        ds.attrs["latitude_limit"] = "%.2f degrees north" % lat_lim
    else:
        ds.attrs["latitude_limit"] = "zonally averaged"
    ds.attrs["average_period_years"] = str(first_year) + "-" + str(last_year)
    return ds


def atmos_dataset(model, first_year: int | None = None, last_year: int | None = None) -> xr.Dataset:
    """
    This function load all the variables needed into one dataset, select the time periode under consideration 
    and calcuates the pressure thickness for the same dimensions and adds it to the dataset

    Parameters
    ----------
    model :          python object, with experiment details as attributes (generated by class Modelinfo )
    first_year :     int, first year to choose for time slicing. Default is None
    last_year :      int, last year to choose for time slicing. Default is None

    Returns
    -------
    ds_atm :         xarray.Dataset with variables needed to calculate the energy transport in the atmophsere
  
    It is useful to reduce the amount of data by selecting a time slice for the period needed
   
    """

    ds_cfmon = read_noresm_cmor(
        model,
        varlist=["ta", "hus"],
        realm="CFmon",
        grid="gn",
        dim="time",
        transform_func=lambda ds: guf.consistent_naming(ds),
    )
    ds_aermon = read_noresm_cmor(
        model,
        varlist=["ua", "va", "zg"],
        realm="AERmon",
        grid="gn",
        dim="time",
        transform_func=lambda ds: guf.consistent_naming(ds),
    )
    ds_atm = xr.merge([ds_cfmon, ds_aermon])
    if first_year or last_year:
        ds_atm = atf.select_time(ds_atm, first_year=first_year, last_year=last_year)
    # calculate pressure thickness
    dp = atf.make_pressure_bnds(ds_atm[["a_bnds", "b_bnds", "ps", "p0"]])
    ds_atm = xr.merge([ds_atm, dp])
    return ds_atm


def aht_yearly(ds: xr.Dataset, lat_lim: int | float) -> xr.Dataset:
    """
    This function calculates the atmospheric energy transport across a given latitude given by lat_lim 
    averaged over the whole time slice of the dataset. If time series i wanted, just remove the .mean(dim='year')
    from aht = pw*(guf.yearly_avg(energy_flux).mean(dim='year')).sum()

    Also included are yearly averages across the given latitude band as a function of height and a function of longitude


    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport 
    lat_lim: int or float, latitude band for which the energy transport is calculated across  
             Please set a value for latitude band. If not this script will crash due to memory issues
    
    Returns
    -------
    ds_out:     xarray.Dataset with yearly averaged atmospheric energy transport across lat_lim 
    """
    ds = atf.select_region(ds, lat_lim=lat_lim)
    ef_tot, ef_moist, ef_dry, ef_kinetic = atf.atmos_energy_flux(
        ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds
    )
    first_year = ds.time.values[0].year
    last_year = ds.time.values[-1].year
    lat_lim = ds.lat.values  # to get the actual value for the latitude band used in the calculations

    def yearly_transport(
        energy_flux: xr.DataArray, energy_type: str, lat_lim: float | int, first_year: int, last_year: int,
    ) -> xr.Dataset:
        """This function calculates yearly mean energy transport across latitude lat_lim"""
        pw = 1e-15  # convert to peta watt
        aht = pw * (guf.yearly_avg(energy_flux).mean(dim="year")).sum()
        print(energy_type + " AHT @ %.2f degrees north: %.4f PW" % (lat_lim, aht.values))
        aht = make_attributes(aht, energy_type, "Yearly", first_year, last_year, lat_lim)
        aht = aht.to_dataset(name="aht_" + energy_type)
        # it can be quite useful to see the the energy transport variation with height as well,
        # but it slows down the calculations, so please comment out all the aht_height stuff if not needed
        aht_height = pw * (guf.yearly_avg(energy_flux).mean(dim="year")).sum(dim="lon")
        aht_height = make_attributes(aht_height, energy_type, "Yearly", first_year, last_year, lat_lim)
        aht_height = aht_height.to_dataset(name="aht_height_" + energy_type)
        # it can be quite useful to see the the energy transport variation with longitude as well,
        # in order to see which region(s) dominates the transport
        # but it slows down the calculations, so please comment out all the aht_lin stuff if not needed
        aht_lon = pw * (guf.yearly_avg(energy_flux).mean(dim="year")).sum(dim="lev")
        aht_lon = make_attributes(aht_lon, energy_type, "Yearly", first_year, last_year, lat_lim)
        return aht_lon.to_dataset(name="aht_lon_" + energy_type)

    ds_out = xr.merge(
        [
            yearly_transport(energy_flux, energy_type, lat_lim, first_year, last_year)
            for energy_flux, energy_type in zip(
                [ef_tot, ef_moist, ef_dry, ef_kinetic], ["total", "latent", "dry_static", "kinetic"],
            )
        ]
    )
    return ds_out


def aht_zonal(ds: xr.Dataset) -> xr.Dataset:
    """
    This function calculates the zonally averaged atmospheric energy transport 
    averaged over the whole time slice of the dataset. If seasonal or monthly averaged are needed instead,
    it is possible to combine several of the functions in this script :)

    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport   
    
    Returns
    -------
    ds_out:     xarray.Dataset with yearly and zonally averaged atmospheric energy transport 

    """

    ef_tot, ef_moist, ef_dry, ef_kinetic = atf.atmos_energy_flux(
        ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds
    )
    first_year = ds.time.values[0].year
    last_year = ds.time.values[-1].year

    def zonal_transport(energy_flux: xr.DataArray, energy_type: str, first_year: int, last_year: int) -> xr.Dataset:
        """This function calculates zonally averaged energy transport"""
        pw = 1e-15  # convert to peta watt
        aht = pw * (guf.yearly_avg(energy_flux).mean(dim="year")).sum(dim=("lon", "lev"))
        aht = make_attributes(aht, energy_type, "Yearly", first_year, last_year, lat_lim=None)
        return aht.to_dataset(name="aht_zonal_" + energy_type)

    ds_out = xr.merge(
        [
            zonal_transport(energy_flux, energy_type, first_year, last_year)
            for energy_flux, energy_type in zip(
                [ef_tot, ef_moist, ef_dry, ef_kinetic], ["total", "latent", "dry_static", "kinetic"],
            )
        ]
    )
    return ds_out


def aht_season(ds: xr.Dataset, lat_lim: int | float) -> xr.Dataset:
    """
    This function calculates the atmospheric energy transport across a given latitude given by lat_lim 
    seaonally averaged (SON, DJF, MAM, JJA) over the whole time slice of the dataset. 

    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport 
    lat_lim: int or float, latitude band for which the energy transport is calculated across  
    
    Returns
    -------
    ds_out:     xarray.Dataset with sesonal (SON, DJF, MAM, JJA) averaged atmospheric energy transport across lat_lim 
    """

    if lat_lim:
        ds = atf.select_region(ds, lat_lim=lat_lim)
    else:
        raise Exception("Please set a value for latitude band. If not this script will crash due to memory issues")
    ef_tot, ef_moist, ef_dry, ef_kinetic = atf.atmos_energy_flux(
        ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds
    )
    first_year = ds.time.values[0].year
    last_year = ds.time.values[-1].year
    lat_lim = ds.lat.values  # to get the actual value for the latitude band used in the calculations

    def seasonal_transport(
        energy_flux: xr.DataArray, energy_type: str, lat_lim: float | int, first_year: int, last_year: int,
    ) -> xr.Dataset:
        pw = 1e-15  # convert to peta watt
        ses_avg = guf.seasonal_avg(energy_flux)
        ses_avg = pw * ses_avg.sum(dim=("lon", "lev"))

        def seasons(da: xr.DataArray, ses: str):
            da = da.drop("season")
            print(energy_type + " AHT @ %.2f degrees north for season %s: %.4f PW" % (lat_lim, ses, da.values))
            da = make_attributes(da, energy_type, ses, first_year, last_year, lat_lim)
            return da.to_dataset(name="aht_" + ses + "_" + energy_type)

        return xr.merge([seasons(ses_avg.sel(season=ses), ses) for ses in ["DJF", "JJA", "MAM", "SON"]])

    ds_out = xr.merge(
        [
            seasonal_transport(energy_flux, energy_type, lat_lim, first_year, last_year)
            for energy_flux, energy_type in zip(
                [ef_tot, ef_moist, ef_dry, ef_kinetic], ["total", "latent", "dry_static", "kinetic"],
            )
        ]
    )
    return ds_out


def aht_monthly(ds: xr.Dataset, lat_lim: int | float) -> xr.Dataset:
    """
    This function calculates the atmospheric energy transport across a given latitude given by lat_lim 
    averaged for each month for the whole time slice of the dataset.
    Also included are montly averages across the given latitude band as a function of height

    Parameters
    ----------
    ds :     xarray.Dataset with variables (ua, va, ta, hus, zg, dp, lon_bnds) needed to calculate the atmospheric energy transport 
    lat_lim: int or float, latitude band for which the energy transport is calculated across . 
              Please set a value for latitude band. If not this script will crash due to memory issues
    
    Returns
    -------
    ds_out:     xarray.Dataset with monthly (Jan, Feb, March, etc.) averaged atmospheric energy transport across lat_lim 
    """
    monthnames_short = [
        "jan",
        "feb",
        "mar",
        "apr",
        "may",
        "june",
        "july",
        "aug",
        "sept",
        "oct",
        "nov",
        "dec",
    ]
    monthnames_long = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    ]
    ds = atf.select_region(ds, lat_lim=lat_lim)
    ef_tot, ef_moist, ef_dry, ef_kinetic = atf.atmos_energy_flux(
        ds.ua, ds.va, ds.ta, ds.hus, ds.zg, ds.dp, ds.lon_bnds
    )
    first_year = ds.time.values[0].year
    last_year = ds.time.values[-1].year
    lat_lim = ds.lat.values  # to get the actual value for the latitude band used in the calculations

    def monthly_transport(
        energy_flux: xr.DataArray,
        energy_type: str,
        lat_lim: float | int,
        first_year: int,
        last_year: int,
        monthnames_short: list,
        monthnames_long: list,
    ) -> xr.Dataset:
        pw = 1e-15  # convert to peta watt
        monthly_avg = energy_flux.groupby("time.month").mean(dim="time")
        # it can be quite useful to see the the energy transport variation with height as well, but it slows down the calculations, so please comment out all the _height stuff if not needed
        monthly_avg_height = pw * monthly_avg.sum("lon")
        monthly_avg = pw * monthly_avg.sum(dim=("lon", "lev"))

        def month_transport(
            monthly_avg: xr.DataArray,
            monthly_avg_height: xr.DataArray,
            month: int,
            monthnames_short: list,
            monthnames_long: list,
        ) -> xr.Dataset:
            da = monthly_avg.sel(month=month).drop("month")
            da_height = monthly_avg_height.sel(month=month).drop("month")
            print(
                energy_type
                + " AHT @ %.2f degrees north for %s: %.4f PW" % (lat_lim, monthnames_long[month - 1], da.values)
            )
            da = make_attributes(da, energy_type, monthnames_long[month - 1], first_year, last_year, lat_lim,)
            da = da.to_dataset(name="aht_" + monthnames_short[month - 1] + "_" + energy_type)
            da_height = make_attributes(
                da_height, energy_type, monthnames_long[month - 1], first_year, last_year, lat_lim,
            )
            da_height = da_height.to_dataset(name="aht_height_" + monthnames_short[month - 1] + "_" + energy_type)
            return xr.merge([da, da_height])

        return xr.merge(
            [
                month_transport(monthly_avg, monthly_avg_height, month, monthnames_short, monthnames_long,)
                for month in range(1, 13)
            ]
        )

    ds_out = xr.merge(
        [
            monthly_transport(
                energy_flux, energy_type, lat_lim, first_year, last_year, monthnames_short, monthnames_long,
            )
            for energy_flux, energy_type in zip(
                [ef_tot, ef_moist, ef_dry, ef_kinetic], ["total", "latent", "dry_static", "kinetic"],
            )
        ]
    )
    return ds_out


if __name__ == "__main__":
    # please change according to your experiment
    expid = "historical"  # name of experiment
    activity_id = "CMIP"  # activity id of experiment i.e. which MIP
    modelname = "NorESM2-LM"  # name of model
    realiz = "r1i1p1f1"  # ensemble member
    outdir = "/"  # path to directory where output is stored

    # Create model object with experiment information (not file specific) as attributes
    # for details see Modelinfo in reading_routines_noresm.py
    model = Modelinfo(name=modelname, activity_id=activity_id, expid=expid, realiz=realiz)
    # ATMOSPHERIC ENERGY TRANSPORT
    # read files. Please note, if you don't limit the number of years you probably will run into memory trouble
    first_year = 2000
    last_year = 2014
    ds_atm = atmos_dataset(model, first_year=first_year, last_year=last_year)
    lat_lim = 66

    # These are just examples, and please just comment out what you don't need
    # yearly values across a given latitude; lat_lim
    ds_out1 = aht_yearly(ds_atm, lat_lim=lat_lim)

    # yearly values, zonally averaged
    ds_out2 = aht_zonal(ds_atm)

    # seasonally avereaged values across a given latitude; lat_lim
    ds_out3 = aht_season(ds_atm, lat_lim=lat_lim)

    # montly averages across a given latitude; lat_lim
    ds_out4 = aht_monthly(ds_atm, lat_lim=lat_lim)

    combined = xr.merge([ds_out1, ds_out2, ds_out3, ds_out4])

    # this is just an example. please change to a filename you find useful
    filename = (
        outdir
        + "AtmosphericEnergyTransport"
        + "_"
        + modelname
        + "_"
        + expid
        + "_"
        + realiz
        + ".%s_%s.nc" % (str(first_year).zfill(4), str(last_year).zfill(4))
    )
    tmp = combined.to_netcdf(filename, compute=False)
    with ProgressBar():
        result = tmp.compute()
